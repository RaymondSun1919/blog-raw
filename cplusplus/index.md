---
title: C++ - dianhsu.top
toc:
  depth_from: 1
  depth_to: 2
  ordered: false
---
@import "/mystyle.less"

# C++ {ignore=True}
> 返回:house:[首页](../index.html)

---------------------------
[TOC]
## 引用和指针
指针和引用主要有以下区别：
- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
- 引用初始化后不能被改变，指针可以改变所指的对象。
- 不存在指向空值的引用，但是存在指向空值的指针。

注意：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能引发错误。所以使用时一定要小心谨慎。


从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：

- 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
- 而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
- 引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。


从编译的角度来看它们之间的区别：

程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

## 程序编译过程
- 编译预处理（编译器处理预编译指令，例如`#define`等）
- 编译、优化阶段
- 汇编过程
- 链接程序（链接外部库）

## 重载，重写（覆盖），隐藏

### 重载
重载从`overload`翻译过来，是指同一可访问区内被声明的几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

- 相同的范围（在同一个作用域中）
- 函数名字相同
- 参数不同列表
- `virtual`关键字可有可无
- 返回类型可以不同

```cpp
int test();
int test(int a);
int test(int a,double b);
int test(double a,int a);
int test(string s);
...
```
### 重写（覆盖）

重写翻译自`override`，是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有`virtual`修饰。

- 不在同一个作用域（分别位于派生类与基类）
- 函数名字相同
- 参数相同列表（参数个数，两个参数列表对应的类型）
- 基类函数必须有 virtual 关键字，不能有 static，大概是多态的原因吧...
- 返回值类型（或是协变），否则报错
- 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的

```cpp
class Base
{
public:
    void test(int a)
    {
        cout<<"this is base"<<endl;
    }
};
class Ship:public Base
{
public:
    void test(int a)
    {
        cout<<"this is Base overwrite function"<<endl;
    }
};
```

### 隐藏

隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

- 不在同一个作用域（分别位于派生类与基类）
- 函数名字相同
- 返回类型可以不同
- 参数不同，此时，不论有无`virtual`关键字，基类的函数将被隐藏（注意别与重载混淆）而不是被重写
- 参数相同，但是基类函数有无`virtual`关键字都会被隐藏。此时，基类的函数被隐藏（注意别与覆盖混淆）

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void test(int a)//有virtual关键字，参数列表不同 
    {
        cout<<"this is base there are"
        " different parameters with virtual"<<endl;
    }
    void test1() 
    {
        cout<<"this is base with the"
        " same parameters with not virtual"<<endl;
    }
    virtual void test2() 
    {
        cout<<"this is base with the"
        " same parameters with virtual"<<endl;
    }
};

class Ship:public Base
{
public:
    void test()
    {
        cout<<"this is Ship there are"
        " different parameters with virtual cover"<<endl;
    }
    void test1() 
    {
        cout<<"this is Ship with the"
        " same parameters with not virtual cover"<<endl;
    }
    void test2() 
    {
        cout<<"this is Ship with the"
        " same parameters with virtual cover"<<endl;
    }
};

int main()
{
    Ship s;
    s.test();
    s.test1();
    s.test2();
    return 0;
}
```

## 多态
在面向对象语言中，接口的多种不同实现方式即为多态。多态是指，用父类的指针指向子类的实例(对象)，然后通过父类的指针调用实际子类的成员函数。

多态性就是允许将子类类型的指针赋值给父类类型的指针，多态是通过虚函数实现的。

多态可以让父类的指针有“多种形态”，这是一种泛型技术。（所谓泛型技术，就是试图使用不变的代码来实现可变的算法）。

## 虚函数，纯虚函数，抽象类，接口，虚基类

### 虚函数定义

在基类的类定义中，定义虚函数的一般形式：
```cpp
virtual 函数返回值类型 虚函数名(形参表)
{
    函数体
}
```
虚函数必须是类的非静态成员函数（且非构造函数），其访问权限是public。

### 虚函数的作用
虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数进行重新定义（形式同上）。在派生类中定义的函数应与虚函数具有相同的形参个数和形参类型(覆盖)，以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。

虚函数可以让成员函数操作一般化，用基类的指针指向不同的派生类的对象时，基类虚成员函数调用基类指针，则会调用其真正指向的对象的成员函数，而不是基类中定义的成员函数（只要派生类改写了该成员函数）。若不是虚函数，则不管基类指针指向哪个派生类对象，调用时都会调用基类中定义的那个函数。

### 实现动态联编需要三个条件
- 必须把需要动态联编的行为定义为类的公共属性的虚函数；
- 类之间存在子类型关系，一般表现为一个类从另一个类公有派生而来；
- 必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数。

### 定义虚函数的限制
- 非类的成员函数不能定义为虚函数，类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。
- 只需要在声明函数的类体中使用关键字`virtual`将函数声明为虚函数，而定义函数时不需要使用关键字`virtual`。
- 如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、参数类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种非虚的同名同返回值同参数个数同参数类型函数。

### 为什么类的静态成员函数不能为虚函数
如果定义为虚函数，那么它就是动态绑定的，也就是在派生类中可以被覆盖的，这与静态成员函数的定义（在内存中只有一份拷贝，通过类名或对象引用访问静态成员）本身就是相矛盾的。

### 为什么构造函数不能为虚函数

因为如果构造函数为虚函数的话，它将在执行期间被构造，而执行期则需要对象已经建立，构造函数所完成的工作就是为了建立合适的对象，因此在没有构建好的对象上不可能执行多态（虚函数的目的就在于实现多态性）的工作。在继承体系中，构造的顺序就是从基类到派生类，其目的就在于确保对象能够成功地构建。构造函数同时承担着虚函数表的建立，如果它本身都是虚函数的话，如何确保vtbl的构建成功呢？

### 虚析构函数

C++开发的时候，用来做基类的类的析构函数一般都是虚函数。当基类中有虚函数的时候，析构函数也要定义为虚析构函数。如果不定义虚析构函数，当删除一个指向派生类对象的指针时，会调用基类的析构函数，派生类的析构函数未被调用，造成内存泄露。

虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这样，当删除指向派生类的指针时，就会首先调用派生类的析构函数，不会有内存泄露的问题了。

一般情况下，如果类中没有虚函数，就不用去声明虚析构函数。当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。
只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。

### 虚函数的实现——虚函数表
虚函数是通过一张虚函数表来实现的，简称V-Table。类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享，类的每个虚函数成员占据虚函数表中的一行。

在这个表中，主要是一个类的虚函数的地址表。这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。在有虚函数的类的实例中，分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就指明了实际所应该调用的函数。

### 纯虚函数

许多情况下，在基类中不能对虚函数给出有意义的实现，则把它声明为纯虚函数，它的实现留给该基类的派生类去做。

纯虚函数的声明格式：
```cpp
virtual <函数返回类型说明符> <函数名> ( <参数表> ) = 0;

```
纯虚函数的作用是为派生类提供一个一致的接口。

### 抽象类(abstract class)

抽象类是指含有纯虚函数的类(至少有一个纯虚函数)，该类不能创建对象(抽象类不能实例化)，但是可以声明指针和引用，用于基础类的接口声明和运行时的多态。

抽象类中，既可以有抽象方法，也可以有具体方法或者叫非抽象方法。抽象类中，既可以全是抽象方法，也可以全是非抽象方法。一个继承于抽象类的子类，只有实现了父类所有的抽象方法才能够是非抽象类。

### 接口

接口是一个概念。它在C++中用抽象类来实现，在C#和Java中用interface来实现。

## 友元函数

## 字节对齐

现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

## 如何避免循环引用

## new和malloc，delete和free

最大的区别：new在申请空间的时候会调用构造函数，malloc不会调用

申请失败返回：new在申请空间失败后返回的是错误码bad\_alloc，malloc在申请空间失败后会返回NULL

属性上：new/delete是C++关键字需要编译器支持，maollc是库函数，需要添加头文件

参数：new在申请内存分配时不需要指定内存块大小，编译器会更具类型计算出大小，malloc需要显示的指定所需内存的大小

成功返回类型：new操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此new是类型安全性操作符。malloc申请内存成功则返回void*，需要强制类型转换为我们所需的类型

自定义类型：new会先调operator new函数，申请足够的内存（底层也是malloc实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数来释放内存（底层是通过free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数

重载：C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回地址。malloc不允许重载。


## 静态绑定和动态绑定的区别

1. 静态绑定发生在编译期，动态绑定发生在运行期；

2. 对象的动态类型可以更改，但是静态类型无法更改；

3. 要想实现动态，必须使用动态绑定；

4. 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；

建议：

绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；

## 浅拷贝和深拷贝

```cpp
class ShallowCopy{
public:
    ShallowCopy(){
        data = new int[10];
    }
    ShallowCopy(const ShallowCopy& obj){
        this->data = obj.data;
    }
    int* data;
};

class DeepCopy{
public:
    DeepCopy(){
        data = new int[10];
    }
    DeepCopy(const DeepCopy& obj){
        memcpy(this->data, obj.data, sizeof(*(obj.data));
    }
    int *data;
};

```

## static的作用
static 是 C/C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。
### static 的引入
我们知道在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。

另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。
### 静态数据的存储
**全局（静态）存储区**:分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。

这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。

static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

**优势**：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
### 在 C/C++ 中static的作用
- 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
- static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
- static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
- 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
- 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

## const的作用
我们经常将 const 变量称为常量（Constant）。创建常量的格式通常为：
```cpp
const type name = value;
```
const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。const 和指针一起使用会有几种不同的顺序，如下所示：
- `const int *A;` const修饰指向的对象，A可变，A指向的对象不可变
- `int const *A;` const修饰指向的对象，A可变，A指向的对象不可变
- `int *const A;` const修饰指针A， A不可变，A指向的对象可变
- `const int *const A;` 指针A和A指向的对象都不可变

## 动态存储区、静态存储区、堆和栈的区别

### 栈区(stack)

由编译器自动分配和释放，存放函数的参数值、局部变量等值。其操作方式类似于数据结构中的栈。

### 堆区(heap)

堆允许程序在运行时动态地申请某个大小的内存。
一般由程序员分配和释放，若程序员不释放，则可能引起内存泄漏。

**堆和数据结构中的堆栈不一样，其结构是链表。**

### 程序代码区

存放函数体的二进制代码。
所有的语句编译后会生成CPU指令存储在代码区。

### 数据段

- 只读数据段
- 已初始化的读写数据段
- 未初始化数据段(BSS)

## inline和define的区别
- define：定义预编译时处理的宏，只是简单的字符串替换，无类型检查。
- inline：关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义，编译阶段完成。
- inline函数可以得到一定效率的提升，和c时代的宏函数相比，inline函数更加安全可靠，这个是以增加空间的消耗为代价的。
- define是在代码处不加任何验证的简单替换；
- inline是将代码插入到调用处，会做参数类型检查。
- 替换方式：define字符串替换；inline是指嵌入代码，在编译过程中不单独产生代码，在调用函数的地方不是跳转，而是把代码 直接写到那里去，对于短小的函数比较实用，且安全可靠。

## STL
### 六大组件
- 容器(container)
- 算法(algorithm)
- 迭代器(iterator)
- 仿函数(functor)
- 配接器(adapter)
- 配置器(allocator)

### 容器
#### 序列式容器
- array
- vector
- priority_queue (heap)
- list
- deque
- stack
- queue

#### 关联式容器
- set (RB-tree)
- map (RB-tree)
- multiset (RB-tree)
- multimap (RB-tree)
- unordered_set (HashTable)
- unordered_map (HashTable)
- unordered_multiset (HashTable)
- unordered_multimap (HashTable)

### 部分算法
- lower_bound
- upper_bound
- prev_permutation
- next_permutation
- find
- reverse
- find_first_of

## C++11新特性

### 强制类型转换，四种cast (C++11)

#### static_cast

将表达式转换为某种类型，语法是 `T t=static_cast<T>(expression)`。
通常用于各种内置类型之间的隐式转换。

@import "code/static_cast_demo.cpp"

在上面的示例中，为了更突出地说明问题，我们在用 auto 变量（类型自动推断）来保存转换后的结果，然后输出转换结果的类型。

#### const_cast
const\_cast 可以修改类型的 const 或 volatile 属性。
通常的用法是将常量转换成非常量，从而可以对这个常量进行修改。
const\_cast 的返回值是一个指向原变量的指针或引用。

@import "code/const_cast_demo.cpp"

显然，转换后变量已经支持修改，即非常量。

#### dynamic\_cast
dynamic\_cast 用于动态类型转换，只能用于转换含有虚函数的类，用于类层次之间的向上（派生类向基类）和向下转换（基类向派生类）。只能转指针或引用，如果是非法的转换，对于指针返回 NULL ，对于引用抛出异常。

之所以叫作动态类型转换，就是因为它通过判断在执行到该语句的时候，变量的运行时类型来进行转换的。

@import "code/dynamic_cast_demo.cpp"

通过示例我们可以看出，基类和派生类之间可以相互转换，但同一基类的不同派生类 (Apple 和 Banana) 之间是不能成功转换的。

#### reinterpret\_cast

reinterpret\_cast 是用来处理无关类型之间的转换。
reinterpret\_cast 几乎可以转换任意类型，但是很容易出问题，我们尽量不要使用。
这里我也不准备花很多篇幅去讲解这个转换，下面用一个例子一笔带过：将一个整数类型转换成指针类型。

@import "code/reinterpret_cast_demo.cpp"
从上面的示例可以看出，我们先将一个指针转换成一个整数，在将这个整数转换成指针，发现两次的指针是相同的。

### 智能指针(C++11)
在C++11中，引入了智能指针。主要有：unique\_ptr, shared\_ptr, weak\_ptr。

| std        | 功能说明                                                                                                                |
| ---------- | ----------------------------------------------------------------------------------------------------------------------- |
| unique_ptr | 独占指针对象，并保证指针所指对象生命周期与其一致                                                                        |
| shared_ptr | 可共享指针对象，可以赋值给shared\_ptr或weak\_ptr。指针所指对象在所有的相关联的shared\_ptr生命周期结束时结束，是强引用。 |
| weak_ptr   | 它不能决定所指对象的生命周期。引用所指对象时，需要lock()成shared\_ptr才能使用。                                         |

### 右值引用(C++11)

#### 左值、右值
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。
在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
举个例子，`int a = b+c`, `a` 就是左值，其有变量名为`a`，通过`&a`可以获取该变量的地址；
表达式`b+c`、函数`int func()`的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，`&(b+c)`这样的操作则不会通过编译。
\subsubsection{右值、将亡值}
在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数`int func()`的返回值，表达式`a+b`；不跟对象关联的字面量值，例如`true`，`2`，`"C"`等。

C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用`T&&`的函数返回值、`std::move`的返回值，或者转换为`T&&`的类型转换函数的返回值。

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

## C++14新特性
## C++17新特性
## C++20新特性
## Make, CMake
- Make: GNU推出的自动化构建工具，配置文件是makefile
- CMake: 跨平台的构建工具，配置文件是CMakeLists.txt 
- 还有一些其他的工具，例如: autoconf, Ninja, configure

## LLVM, Clang
我们可以认为LLVM是一个完整的编译器架构，也可以认为它是一个用于开发编译器、解释器相关的库。

Clang是一个C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。

### Clang 特性

速度快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 比 GCC 快2倍多。

内存占用小：Clang 内存占用是源码的 `130%`，Apple GCC 则超过 `10` 倍。

诊断信息可读性强：其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有提示，相比之下 GCC 的提示很天书。

兼容性好：Clang 从一开始就被设计为一个API，允许它被源代码分析工具和 IDE 集成。GCC 被构建成一个单一的静态编译器，这使得它非常难以被作为 API 并集成到其他工具中。

Clang有静态分析，GCC没有。

Clang使用BSD许可证，GCC使用GPL许可证。

